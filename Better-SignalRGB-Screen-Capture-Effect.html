<!-- Better SignalRGB Screen Capture - Multi-Source Canvas Effect -->

<head>
    <title>Better SignalRGB Screen Capture - Multi-Source Canvas</title>
    <meta name="description" content="Multi-source screen capture canvas with per-source styling support" />
    <meta name="publisher" content="Better SignalRGB Screen Capture" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
        }

        #canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .source-element {
            position: absolute;
            display: block;
            max-width: none;
            max-height: none;
            transform-origin: center center;
        }

        .crop-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .source-element video,
        .source-element img {
            width: 100%;
            height: 100%;
            object-fit: fill;
        }
    </style>
</head>

<body>
    <div id="canvas"></div>
</body>

<script>
    (() => {
        "use strict";

        // Constants
        const SENDER = "BetterSignalRGBScreenCapture";
        const canvas = document.getElementById("canvas");

        // Source management
        const sources = new Map();
        let frameCount = 0;
        let errorCount = 0;

        // Debug logging
        function log(message) {
            console.log(`[${new Date().toLocaleTimeString()}] ${message}`);
        }

        // Get or create source state
        function getSource(id) {
            if (!sources.has(id)) {
                sources.set(id, {
                    id: id,
                    expect: 0,
                    mime: "",
                    chunks: new Map(),
                    outerStyle: "",
                    cropStyle: "",
                    element: null,
                    lastUpdate: Date.now()
                });
            }
            return sources.get(id);
        }

        // Create or update DOM element for source
        function ensureElement(source) {
            const tag = source.mime.startsWith("video/") ? "video" : "img";

            if (!source.element || source.element.tagName.toLowerCase() !== "div") {
                // Remove old element if exists
                if (source.element) {
                    source.element.remove();
                }

                // Create container div
                source.element = document.createElement("div");
                source.element.className = "source-element";
                source.element.dataset.sourceId = source.id;

                // Create crop wrapper
                const cropWrapper = document.createElement("div");
                cropWrapper.className = "crop-wrapper";

                // Create media element
                const mediaElement = document.createElement(tag);
                if (tag === "video") {
                    mediaElement.autoplay = true;
                    mediaElement.loop = true;
                    mediaElement.muted = true;
                }

                // Error handling
                mediaElement.onerror = function () {
                    errorCount++;
                    log(`Error loading ${tag} for source ${source.id}, hiding element.`);
                    this.style.display = 'none';
                };

                // Load success
                mediaElement.onload = function () {
                    log(`Successfully loaded frame for source ${source.id}`);
                    this.style.display = 'block';
                };

                cropWrapper.appendChild(mediaElement);
                source.element.appendChild(cropWrapper);
                canvas.appendChild(source.element);
            }

            return source.element;
        }

        // Assemble and render frame
        function assembleAndRender(source) {
            if (!source.expect || source.chunks.size < source.expect) {
                return false;
            }

            // Assemble base64 data in correct order
            const orderedChunks = [];
            for (let i = 0; i < source.expect; i++) {
                const chunk = source.chunks.get(i);
                if (!chunk) {
                    log(`Missing chunk ${i} for source ${source.id}`);
                    return false;
                }
                orderedChunks.push(chunk);
            }

            const base64Data = orderedChunks.join("");

            // Validate base64 data
            if (base64Data.length % 4 !== 0) {
                log(`Invalid base64 data length for source ${source.id}: ${base64Data.length}`);
                errorCount++;
                return false;
            }

            // Create data URI
            const dataUri = `data:${source.mime};base64,${base64Data}`;

            // Ensure element exists
            const element = ensureElement(source);

            // Update element styles
            element.style.cssText = source.outerStyle;
            const cropWrapper = element.querySelector('.crop-wrapper');
            if (cropWrapper) {
                cropWrapper.style.cssText = source.cropStyle;
            }

            // Update media element
            const mediaElement = element.querySelector('img, video');
            if (mediaElement) {
                mediaElement.src = dataUri;
            }

            // Update stats
            frameCount++;
            source.lastUpdate = Date.now();

            // Clean up for next frame
            source.chunks.clear();
            source.expect = 0;

            return true;
        }

        // Canvas API event handler
        window.onCanvasApiEvent = function (event) {
            if (event.sender !== SENDER) {
                return; // Ignore events from other senders
            }

            // Decode URL-encoded event data
            const msg = decodeURIComponent(event.event);

            // Handle header: header:filename:mime:chunkCount:style
            if (msg.startsWith("header:")) {
                const parts = msg.split(":");
                if (parts.length < 5) {
                    log(`Invalid header format: ${msg}`);
                    errorCount++;
                    return;
                }

                const filename = parts[1];
                const mime = parts[2];
                const chunkCount = parseInt(parts[3], 10);
                const styles = parts.slice(4).join(":"); // Rejoin in case style contains colons

                // Extract source ID from filename (should be GUID.jpg)
                const sourceId = filename.split(".")[0];

                const source = getSource(sourceId);
                source.mime = mime;
                source.expect = chunkCount;

                // Split styles into outer and crop styles
                const [outerStyle, cropStyle] = styles.split("|");
                source.outerStyle = outerStyle.substring(6); // Remove "outer:"
                source.cropStyle = cropStyle.substring(5);   // Remove "crop:"
                source.chunks.clear();

                return;
            }

            // Handle data: data:sourceId:index:payload
            if (msg.startsWith("data:")) {
                const parts = msg.split(":");
                if (parts.length < 4) {
                    log(`Invalid data format: ${msg.substring(0, 50)}...`);
                    errorCount++;
                    return;
                }
                const sourceId = parts[1];
                const index = parseInt(parts[2], 10);
                const payload = parts.slice(3).join(":");

                if (isNaN(index) || !payload) {
                    log(`Invalid chunk data: index=${index}, payload length=${payload.length}`);
                    errorCount++;
                    return;
                }

                const source = sources.get(sourceId);
                if (source) {
                    source.chunks.set(index, payload);
                }

                return;
            }

            // Handle end marker: end:sourceId
            if (msg.startsWith("end:")) {
                const parts = msg.split(":");
                const sourceId = parts[1];
                const source = sources.get(sourceId);

                if (source) {
                    assembleAndRender(source);
                }

                return;
            }

            // Handle remove event: remove:sourceId
            if (msg.startsWith("remove:")) {
                const parts = msg.split(":");
                const sourceId = parts[1];
                const source = sources.get(sourceId);

                if (source) {
                    log(`Removing source: ${sourceId}`);
                    if (source.element) {
                        source.element.remove();
                    }
                    sources.delete(sourceId);
                }
                return;
            }

            // Unknown event type
            log(`Unknown event type: ${msg.substring(0, 50)}...`);
        };

        // Periodic cleanup for stale sources
        setInterval(() => {
            const now = Date.now();
            const staleTimeout = 30000; // 30 seconds

            for (const [id, source] of sources.entries()) {
                if (now - source.lastUpdate > staleTimeout) {
                    log(`Removing stale source: ${id}`);
                    if (source.element) {
                        source.element.remove();
                    }
                    sources.delete(id);
                }
            }
        }, 10000); // Check every 10 seconds

        // Stats logging
        setInterval(() => {
            if (frameCount > 0) {
                log(`Stats: ${frameCount} frames, ${errorCount} errors, ${sources.size} active sources`);
            }
        }, 30000); // Log every 30 seconds

        // Initialize
        log(`Multi-source Canvas effect initialized (sender: ${SENDER})`);
        log(`Ready to receive frames from Better SignalRGB Screen Capture`);
    })();
</script>